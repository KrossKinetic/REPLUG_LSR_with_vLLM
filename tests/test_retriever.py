"""
Test the retriever which takes in a list of queries and returns a list of (lists of) retrieved documents.
    
FAISS-CPU test:
    python3 tests/test_retriever.py \
        --re_model_name_or_path "facebook/contriever" \
        --passages /checkpoint/${USER}/retrofit/re_data/psgs_w100.tsv \
        --passages_embeddings "/checkpoint/swj0419/contriever/passages_[01][0123456789]" \

FAISS-GPU test:
    # need 4 GPUs on FAIR cluster to load the Wikipedia 2018 index
    srun --gpus-per-node 4 --nodes 1  --partition learnlab,devlab   --time 360  --pty /bin/bash -l  
    python3 tests/test_retriever.py \
        --re_model_name_or_path "facebook/contriever" \
        --passages /checkpoint/${USER}/retrofit/re_data/psgs_w100.tsv \
        --passages_embeddings "/checkpoint/swj0419/contriever/passages_[01][0123456789]" \
        --use-faiss-gpu
"""
import argparse
import json
import os
import sys

script_dir = os.path.dirname(os.path.realpath(__file__))
repo_root = os.path.join(script_dir, "..")
sys.path.append(repo_root)
from retriever import Retriever
from downstream_eval.argument import add_retriever_args


gt_passages = {
    "Find the degree for the given field extension Q(sqrt(2), sqrt(3), sqrt(18)) over Q.\n(A) 0\n(B) 4\n(C) 2\n(D) 6": [
        "e. All signers and verifiers of signatures will know n, q, b, k, \u03a6(x), a(x) and \u03b2 = b-k. An entity wishing to sign messages generates its public key through the following steps: The polynomials s(x) and e(x) serve as the private key and t(x) is the corresponding public key. The security of this signature scheme is based on the following problem. Given a polynomial t(x) find small polynomials f(x) and f(x) such that: a(x)\u00b7f(x) + f(x) = t(x) If this problem is difficult to solve, then the signature scheme will be difficult to forge. [See the Wikipedia article on",            
        "sizes of n, q, b, and k. Details on setting these parameters can be found in references 5 and 6 below. As noted above, the polynomial \u03a6(x) which defines the ring of polynomials used will be x + 1. Finally, a(x) will be a randomly chosen and fixed polynomial with coefficients from the set { -(q-1)/2 to (q-1)/2 }. The polynomial a(x) should be chosen in a \"Nothing Up My Sleeve\" manner such as one-way hashing the output of a true noise random number generator (TRNG) or using the digital expansion of well known mathematical constans such as pi or",
        "generated by the previous coordinates. Therefore, the degree of the field extension corresponding to each new coordinate is 2 or 1. So, given a coordinate of any constructed point, we may proceed inductively backwards through the - and -coordinates of the points in the order that they were defined until we reach the original pair of points (0,0) and (1,0). As every field extension has degree 2 or 1, and as the field extension over of the coordinates of the original pair of points is clearly of degree 1, it follows from the tower rule that the degree of the",
        "= (\"X\" : \"Y\" : \"Z\") be a point, then the doubling formula is given by: The cost of this algorithm is three multiplications + three squarings + 11 additions + 3\u00d72. If formula_66 is a point over the Hessian curve with parameter d=-1, then the coordinates of formula_67 are given by: X = (2.(-1)-2)(-1+1+1) = -4 Y = (-4-2.(-1))((-1)+1+1) = -2 Z = (-1-(-1))((-4)+2.2) = 0 That is, formula_68 There is another coordinates system with which a Hessian curve can be represented; these new coordinates are called extended coordinates. They can speed up the addition and doubling. To have",
        "typically chosen by: The Toom\u2013Cook approach to computing the polynomial product \"p\"(\"x\")\"q\"(\"x\") is a commonly used one. Note that a polynomial of degree \"d\" is uniquely determined by \"d\" + 1 points (for example, a line - polynomial of degree one is specified by two points). The idea is to evaluate \"p\"(\u00b7) and \"q\"(\u00b7) at various points. Then multiply their values at these points to get points on the product polynomial. Finally interpolate to find its coefficients. Since , we will need points to determine the final result. Call this \"d\". In the case of Toom-3, \"d\" = 5. The",
        "y = 1/(8y)x+((-a+40a)/(4y))x+((ay+(16a-640a))/(4y))x+((-4ay-512a)/y) The fastest addition is the following one (comparing with the results given in: http://hyperelliptic.org/EFD/g1p/index.html), and the cost that it takes is 4 multiplications, 4 squaring and 10 addition. A = Y-Y AA = A B = X-X CC = B F = XCC Z = 2CC D = XZ ZZ = Z X = 2(AA-F)-aZ-D Y = ((A+B)-AA-CC)(D-X)-YZZ Let formula_11. Let P=(X,Y)=(2,1), Q=(X,Y)=(1,-1) and a=1, then A=2 AA=4 B=1 CC=1 F=2 D=4 ZZ=16 Y=336 Thus, P+Q=(-4:336:4) The following algorithm is the fastest one (see the following link to compare: http://hyperelliptic.org/EFD/g1p/index.html), and the cost that it takes is",
        "1 multiplication, 5 squaring and 7 additions. A = X B = A-a16 C = aA YY = Y YY = 2YY Z = 2YY X = B V = (Y+B)2-YY-X Y = V(X+64C+a(YY-C)) ZZ = Z Let formula_11 and a=1. Let P=(-1,2), then Q=[2]P=(x3,y3) is given by: A=1 B=-15 C=2 YY=4 YY=8 Z=16 X=225 V=27 Y=9693 ZZ=256 Thus, Q=(225:9693:16). The addition and doubling computations should be as fast as possible, so it is more convenient to use the following representation of the coordinates: formula_13 are represented by formula_14 satisfying the following equations: formula_5 formula_16 formula_17 Then, the Doubling-oriented Doche\u2013Icart\u2013Kohel",
        "width that brackets the zero is obtained. The decision step for this process is first to choose the midpoint c =(a+b) / 2 and then to analyze the three possibilities that might rise. If f (a) and f (b) have opposite signs, a zero lies in [a, c]. If f (a) and f (b) have opposite signs, a zero lies in [c, b]. If f (c)=0, then the zero is c. If either case (1) or (2) occurs, an interval half as wide as the original interval that contains the root. Maximum Power Point Tracking Using Bisection Search Method: In",
        "the field. The second operation (doubling) has a time-cost of 2M + 2S + 1D, where D denotes the multiplication of a general element by a constant; notice that the constant is formula_27, so formula_28 can be chosen in order to have a small D. The following algorithm represents a doubling of a point formula_29 on an elliptic curve in the Montgomery form. It is assumed that formula_30. The cost of this implementation is 1M + 2S + 1*A + 3add + 1*4. Here M denotes the multiplications required, S indicates the squarings, and a refers to the multiplication by",
        "case in which the inputs (\"x\", \"y\") and (\"x\", \"y\") are known to be equal. Since (\"x\", \"y\") is on the Edwards curve, one can substitute the coefficient by (\"x\" + \"y\" \u2212 1)/\"x\"\"y\" as follows: This reduces the degree of the denominator from 4 to 2 which is reflected in faster doublings. A general addition in Edwards coordinates takes 10M + 1S + 1C + 1D + 7a and doubling costs 3M + 4S + 3C + 6a where M is field multiplications, S is field squarings, D is the cost of multiplying by a selectable curve parameter and"
    ],
    "Let p = (1, 2, 5, 4)(2, 3) in S_5 . Find the index of <p> in S_5.\n(A) 8\n(B) 2\n(C) 24\n(D) 120": [
        "one or two of them. If P is in two (say the B and C zones intersection) then setting P' = A implies d(P') = d(A) < d(P) by the dogleg rule. Alternatively if P is in only one zone, say the A-zone, then d(P') < d(P) where P' is the intersection of AP and BC. So for every point P outside \u0394 there exists a point P' in \u03a9 such that d(P') < d(P). Case 1. The triangle has an angle \u2265 120\u00b0. Without loss of generality suppose that the angle at A is \u2265 120\u00b0. Construct the equilateral",
        "outside \u0394. From above a point P' \u0454 \u03a9 exists such that d(P') < d(P) and as d(A) \u2264 d (P') it follows that d(A) < d(P) for all P outside \u0394. Thus d(A) < d(P) for all P \u2260 A which means that A is the Fermat point of \u0394. In other words, the Fermat point lies at the obtuse angled vertex. Case 2. The triangle has no angle \u2265 120\u00b0. Construct the equilateral triangle BCD and let P be any point inside \u0394 and construct the equilateral triangle CPQ. Then CQD is a 60\u00b0 rotation of CPB about",
        "if it is 3, the other side is white. The probability that the other side is black is . This probability can be derived in the following manner: Let random variable B equal the a black face (i.e. the probability of a success since the black face is what we are looking for). Using Kolmogorov's Axiom of all probabilities having to equal 1, we can conclude that the probability of drawing a white face is 1 \u2212 P(B). Since P(B) = P(1) + P(2) therefore P(B) = + = . Likewise we can do this P(white face)=1 \u2212 = .",
        "in 12 of the 24 sequences. Therefore, A has an index of power 1/2. The others have an index of power 1/6. Curiously, B has no more power than C and D. When you consider that A's vote determines the outcome unless the others unite against A, it becomes clear that B, C, D play identical roles. This reflects in the power indices. Suppose that in another majority-rule voting body with formula_1 members, in which a single strong member has formula_2 votes and the remaining formula_3 members have one vote each. It then turns out that the power of the",
        "The path initiator has probable innocence against c collaborators in case formula_7 Proof: we want to show that pf > 1/2 if formula_7 note that: P(H) = formula_9 in order for the first collaborator to be in the ith position on the path, the path must first wander to i-1 noncollaborators each time with probability of formula_10,each of which chooses to forward the path with probability pf, and then to a collaborator with probability formula_11. The next two facts follow immediately from this P(H) = formula_12 P(H) = formula_13 P(H) = formula_11 P(I|H) = formula_15 P(I|H) = formula_16 Now, P(I)",
        "1) \u00b7 6 = 12.<br> Write 7 to 12 with 7 aligned with 1. 6. \"x\" = 2.<br> \"xn\" + 1 = 2 \u00b7 6 + 1 = 13.<br> (\"x\" + 1)\"n\" = (2 + 1) \u00b7 6 = 18.<br> Write 13 to 18.<br> Repeat for the next few lines. 7 and 8. Sieving 9. Sieving 10. The resulting list contains a non-prime number of 25 which is 5. Use other methods such as a sieve to eliminate it to arrive at Note that by using exactly the next prime number of 5 wheel cycles and eliminating the multiple(s) of",
        "function as a component in oil price forecasting. The index was first published in January 2015. It is updated quarterly and made freely available to the public via the index website and Twitter feed. The index is independent and is not owned by any institutions, companies or governments. Country analysts are asked whether political developments during the coming three months are likely to lead to reduced, unchanged, or increased oil exports from a given country. The following diffusion index formula is used to process their answers: INDEX = (P1*1) + (P2*0.5) + (P3*0) where: An index number of 50 means",
        "bounds were obtained:<br> formula_41 Many optimal rulers are of the form W(r,s) = 1^r, r+1, (2r+1)^r, (4r+3)^s, (2r+2)^(r+1), 1^r, where a^b represents b segments of length a. Thus, if r = 1 and s = 2, then W(1,2) has (in order): 1 segment of length 1, 1 segment of length 2, 1 segment of length 3, 2 segments of length 7, 2 segments of length 4, 1 segment of length 1 That gives the ruler {0, 1, 3, 6, 13, 20, 24, 28, 29}. The length of a Wichmann ruler is 4r(r+s+2)+3(s+1) and the number of marks is 4r+s+3. Note",
        "a gas) and the relationships between them (analogous to the gas equation). Thus his metrics are actually not just complexity metrics. For a given problem, Let: From these numbers, several measures can be calculated: The difficulty measure is related to the difficulty of the program to write or understand, e.g. when doing code review. The effort measure translates into actual coding time using the following relation, Halstead's delivered bugs (B) is an estimate for the number of errors in the implementation. Let us consider the following C program: The unique operators are: main, (), {}, int, scanf, &, =, +,",
        "d(P) = AD < d(P). Now allow P to range outside \u0394. From above a point P' \u0454 \u03a9 exists such that d(P') < d(P) and as d(P) \u2264 d(P') it follows that d(P) < d(P) for all P outside \u0394. That means P is the Fermat point of \u0394. In other words, the Fermat point is coincident with the first isogonic center. Let \"O\", \"A\", \"B\", \"C\", \"X\" be any five points in a plane. Denote the vectors formula_1 by a, b, c, x respectively, and let i, j, k be the unit vectors from \"O\" along a, b,"
    ],
    "Find all zeros in the indicated finite field of the given polynomial with coefficients in that field. x^5 + 3x^3 + x^2 + 2x in Z_5\n(A) 0\n(B) 1\n(C) 0,1\n(D) 0,4": [
        "For example, if the polynomial used to define the finite field GF(2) is \"p\" = \"x\" + \"x\" + \"x\" + \"x\" + 1, and \"a\" = \"x\" + \"x\" + \"x\" + 1 is the element whose inverse is desired, then performing the algorithm results in the computation described in the following table. Let us recall that in fields of order 2, one has -\"z\" = \"z\" and \"z\" + \"z\" = 0 for every element \"z\" in the field). Note also that 1 being the only nonzero element of GF(2), the adjustment in the last line of the",
        "two numbers in the GF(2^8) finite field defined uint8_t gmul(uint8_t a, uint8_t b) { This example has cache, timing, and branch prediction side-channel leaks, and is not suitable for use in cryptography. This D program will multiply numbers in Rijndael's finite field and generate a PGM image: Multiply two numbers in the GF(2^8) finite field defined by the polynomial x^8 + x^4 + x^3 + x + 1. ubyte gMul(ubyte a, ubyte b) pure nothrow { void main() { This example does not use any branches or table lookups in order to avoid side channels and is therefore suitable for",
        "in the second line in () formula_18 was added. By doing so formula_19 can be further used. By using the fact, that formula_4 is traceless (formula_21) equation () simplifies to: _D & = -\\frac{D_z}{2}S(S+1)+\\frac{1}{2}D_z S_z^2+\\frac{D_x-D_y}{2}(S_x^2-S_y^2)+D_zS_z^2 \\\\ By defining D and E parameters equation () becomes to: _D =D\\left(S_z^2-\\frac{1}{3}S(S+1)\\right)+E(S_x^2-S_y^2) with formula_22 and formula_23 (measurable) zero field splitting values. Zero field splitting Zero field splitting (ZFS) describes various interactions of the energy levels of a molecule or ion resulting from the presence of more than one unpaired electron. In quantum mechanics, an energy level is called degenerate if it corresponds to two",
        "employs the following reducing polynomial for multiplication: For example, {53} \u2022 {CA} = {01} in Rijndael's field because and Multiplication in this particular finite field can also be done using a modified version of the \"peasant's algorithm\". Each polynomial is represented using the same binary notation as above. Eight bits is sufficient because only degrees 0 to 7 are possible in the terms of each (reduced) polynomial. This algorithm uses three variables (in the computer programming sense), each holding an eight-bit representation. a and b are initialized with the multiplicands; p accumulates the product and must be initialized to 0.",
        "condition of the quotient polynomial will be poorer when multiple and clustered zeros are involved. If multiple order zeros are extremely far from the unit circle, the special methods for handling multiple roots developed by Zhonggang Zeng are used. Zeng\u2019s method is powerful but slow, and hence only used in special cases [6]. References Successful completion of the factoring of a polynomial requires matching zeros on the complex plane measured by the convergence of Laguerre\u2019s algorithm on each of the zeros. It also requires matching the polynomial reconstructed from the found zeros with the original polynomial by measuring the maximum",
        "\"c\" x + \"d\" y with determinant \"a\" \"d\" \u2212 \"b\" \"c\" = 1 . These substitutions form the special linear group \"SL\". One can ask for all polynomials in A, B, and C that are unchanged by the action of \"SL\"; these are called the invariants of binary quadratic forms and turn out to be the polynomials in the discriminant. More generally, one can ask for the invariants of homogeneous polynomials A \"x\" \"y\" + ... + A x \"y\" of higher degree, which will be certain polynomials in the coefficients A, ..., A, and more generally still, one",
        "leaving all unknown zeros intact, thus producing a lower degree polynomial whose zeros may be easier to find. Abstractly, the method is as follows: Find the factors of To do this one would use trial and error (or the rational root theorem) to find the first x value that causes the expression to equal zero. To find out if formula_17 is a factor, substitute formula_18 into the polynomial above: As this is equal to 18 and not 0 this means formula_17 is not a factor of formula_23. So, we next try formula_24 (substituting formula_25 into the polynomial): This is equal",
        "sizes of n, q, b, and k. Details on setting these parameters can be found in references 5 and 6 below. As noted above, the polynomial \u03a6(x) which defines the ring of polynomials used will be x + 1. Finally, a(x) will be a randomly chosen and fixed polynomial with coefficients from the set { -(q-1)/2 to (q-1)/2 }. The polynomial a(x) should be chosen in a \"Nothing Up My Sleeve\" manner such as one-way hashing the output of a true noise random number generator (TRNG) or using the digital expansion of well known mathematical constans such as pi or",
        "to control error, the unfactoring (multiplying the found roots together) is done in the FFT domain (for degree larger than 500) and the deflation is done partly in the FFT domain and partly in the coefficient domain, depending on a combination of stability, error accumulation, and speed factors. For random coefficient polynomials, the number of zeros missed by the grid search and polish stages ranges from 0 to 10 or occasionally more. In factoring one 2 million degree polynomial, the search and polish stages found all 2 million zeros in one grid search and required no deflation which shows the",
        "some components, the direct computation may be dramatically faster. If one wants to saturate with respect to several polynomials formula_64 or with respect to a single polynomial which is a product formula_65 there are three ways to proceed which give the same result but may have very different computation times (it depends on the problem which is the most efficient). Hilbert's Nullstellensatz has two versions. The first one asserts that a set of polynomials has an empty set of common zeros in an algebraic closure of the field of the coefficients if and only if 1 belongs to the generated"
    ],
    "Statement 1 | A factor group of a non-Abelian group is non-Abelian. Statement 2 | If K is a normal subgroup of H and H is a normal subgroup of G, then K is a normal subgroup of G.\n(A) True, True\n(B) False, False\n(C) True, False\n(D) False, True": [
        "the induction. Now take \"t\"=\"s\" to obtain (d). (d)\u2192(e): Note that a P-group of order \"p\" has a normal subgroup of order \"p\" for all 1\u2264\"m\"\u2264\"k\". Since \"G\" is a direct product of its Sylow subgroups, and normality is preserved upon direct product of groups, \"G\" has a normal subgroup of order \"d\" for every divisor \"d\" of |\"G\"|. (e)\u2192(a): For any prime \"p\" dividing |\"G\"|, the Sylow \"p\"-subgroup is normal. Thus we can apply (c) (since we already proved (c)\u2192(e)). Statement (d) can be extended to infinite groups: if \"G\" is a nilpotent group, then every Sylow subgroup \"G\"",
        "and maximal subgroups of the semigroup: each idempotent element is the identity element of a unique maximal subgroup. Any proper subgroup of a finite group is contained in some maximal subgroup, since the proper subgroups form a finite partially ordered set under inclusion. There are, however, infinite Abelian groups that contain no maximal subgroups, for example the Pr\u00fcfer group. Similarly, a normal subgroup N of G is said to be a maximal normal subgroup (or maximal proper normal subgroup) of G if N<G and there is no normal subgroup K of G such that N<K<G. We have the following theorem:",
        "never true: that is, always false, regardless of the input value of p Logical identity is an operation on one logical value p, for which the output value remains p. The truth table for the logical identity operator is as follows: Logical negation is an operation on one logical value, typically the value of a proposition, that produces a value of \"true\" if its operand is false and a value of \"false\" if its operand is true. The truth table for NOT p (also written as \u00acp, Np, Fpq, or ~p) is as follows: There are 16 possible truth functions",
        "analysis would determine the order of the sextet group and hence |M|. It is convenient to arrange the 24 points into a 6-by-4 array: A E I M Q U B F J N R V C G K O S W D H L P T X Moreover, it is convenient to use the elements of the field F to number the rows: 0, 1, u, u. The sextet group has a normal abelian subgroup H of order 64, isomorphic to the hexacode, a vector space of length 6 and dimension 3 over F. A non-zero element in H",
        "definition should not use the notion of inverse operation anymore. The set S is said to be a semigroup generating set of G if each element of G is a finite sum of elements of S. Similarly, a set S is said to be a monoid generating set of G if each non-zero element of G is a finite sum of elements of S. For example {1} is a monoid generator of the set of non-negative natural numbers formula_4. The set {1} is also a semigroup generator of the positive natural numbers formula_5. However, the integer 0 can not be",
        "is abelian since formula_1 by an elementary result of group theory. The converse of this statement is not true; for example, the (additive) cyclic group Z of integers modulo 6 is abelian, but the number 2 has order 3: The relationship between the two concepts of order is the following: if we write for the subgroup generated by \"a\", then For any integer \"k\", we have In general, the order of any subgroup of \"G\" divides the order of \"G\". More precisely: if \"H\" is a subgroup of \"G\", then As an immediate consequence of the above, we see that",
        "yields two open intervals). By connectedness, no point of Z\\B can lie between two points of B, and no point of Z\\A can lie between two points of A. Therefore, either A < B or B < A. Assume without loss of generality that A < B. If a is any point in A, then p < a and (p,a)formula_7 A. Then (-1,a)=[p,a), so [p,a) is open. {p}\u222aA=[p,a)\u222aA, so {p}\u222aA is an open subset of M and hence M = ({p}\u222aA) \u222a B is the union of two disjoint open subsets of M so M is not connected, a contradiction.",
        "is not true (assuming that we are dealing with concrete statements that are either true or not true): We can apply the same process the other way round: We also know that B is either true or not true. If B is not true, then A is also not true. However, it is given that A is true; so, the assumption that B is not true leads to contradiction and must be false. Therefore, B must be true: Combining the two proved statements makes them logically equivalent: Logical equivalence between two propositions means that they are true together or false",
        "the truth value \"true\" and 0 to be the truth value \"false\" and the operation to be the logical connective \"and\", we obtain this semigroup in logic. It is isomorphic to the monoid {0,1} under multiplication. It is also isomorphic to the semigroup under matrix multiplication. The Cayley table for the semigroup (Z,+) is given below: This group is isomorphic to the cyclic group Z and the symmetric group S. Let \"A\" be the three-element set {1, 2, 3}. Altogether, a total of 3 = 19683 different binary operations can be defined on \"A\". 113 of the 19683 binary operations",
        "the sequence is unbounded above. Therefore, without loss of generality, let be some natural power of that is greater than . So, if we have terms, then let us denote their arithmetic mean by , and expand our list of terms thus: We then have: so and as desired. The following proof uses mathematical induction and some basic differential calculus. Induction basis: For the statement is true with equality. Induction hypothesis: Suppose that the AM\u2013GM statement holds for all choices of non-negative real numbers. Induction step: In order to prove the statement for non-negative real numbers , we need to"
    ]
}


def main():
    parser = argparse.ArgumentParser()
    parser = add_retriever_args(parser)
    args = parser.parse_args()
    retriever = Retriever(args)

    queries = [
        # "Find all c in Z_3 such that Z_3[x]/(x^2 + c) is a field.",
        # "Statement 1 | If aH is an element of a factor group, then |aH| divides |a|. Statement 2 | If H and K are subgroups of G then HK is a subgroup of G.",
        # "Statement 1 | Every element of a group generates a cyclic subgroup of the group. Statement 2 | The symmetric group S_10 has 10 elements.",
        # "Statement 1| Every function from a finite set onto itself must be one to one. Statement 2 | Every subgroup of an abelian group is abelian.",
        # "Find the characteristic of the ring 2Z."
        # "Find the degree for the given field extension Q(sqrt(2), sqrt(3), sqrt(18)) over Q.",
        "Find the degree for the given field extension Q(sqrt(2), sqrt(3), sqrt(18)) over Q.\n(A) 0\n(B) 4\n(C) 2\n(D) 6",
        # "Let p = (1, 2, 5, 4)(2, 3) in S_5. Find the index of <p> in S_5.",
        "Let p = (1, 2, 5, 4)(2, 3) in S_5 . Find the index of <p> in S_5.\n(A) 8\n(B) 2\n(C) 24\n(D) 120",
        # "Find all zeros in the indicated finite field of the given polynomial with coefficients in that field. x^5 + 3x^3 + x^2 + 2x in Z_5",
        "Find all zeros in the indicated finite field of the given polynomial with coefficients in that field. x^5 + 3x^3 + x^2 + 2x in Z_5\n(A) 0\n(B) 1\n(C) 0,1\n(D) 0,4",
        # "Statement 1 | A factor group of a non-Abelian group is non-Abelian. Statement 2 | If K is a normal subgroup of H and H is a normal subgroup of G, then K is a normal subgroup of G.",
        "Statement 1 | A factor group of a non-Abelian group is non-Abelian. Statement 2 | If K is a normal subgroup of H and H is a normal subgroup of G, then K is a normal subgroup of G.\n(A) True, True\n(B) False, False\n(C) True, False\n(D) False, True",
        # "Where does Barack Obama live?",
        # "The Spring Festival is an important holiday in China."
    ]

    for i, (docs, scores) in enumerate(retriever.retrieve_passage(queries)):
        query = queries[i]
        print(f"Question: {query}")
        # print(json.dumps(docs, indent=4))
        assert(query in gt_passages)
        query_gt_passages = gt_passages[query]
        num_mismatch = 0
        for j in range(min(len(query_gt_passages), len(docs))):
            if query_gt_passages[j] != docs[j]["text"]:
                print(f"ERROR: DOC {j} MISMATCHED with the ground truths used in REPLUG paper")
                num_mismatch += 1
            print("GROUND TRUTH:", query_gt_passages[j])
            print("RETRIEVED:", docs[j]["text"])
        if num_mismatch == 0:
            print("PASSED TEST")
        print()


if __name__ == "__main__":
    main()